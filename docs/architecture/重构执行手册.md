## CRM Lite 重构执行手册（无生产数据版）

### 目录
- 目标与范围
- 执行路线图（PR 切片）
- 统一约束与不变量
- 落地步骤（可复制到 Cursor）
- Step 0：项目勘察（只读）
- PR-0：引入域包与事务封装（不改行为）
- PR-1：Catalog/CRM 迁移（纯搬家）
- PR-2：Billing（钱包）重构：余额只读 + 幂等
- PR-3：Sales（订单）收口：快照 + 钱包扣减/退款
- DDL 与迁移文件模板
- 自动化测试计划
- CI/构建规范
- 回滚策略
- 交付验收清单

---

### 目标与范围
- 将 `internal/service/*` 重构为有边界的单体：`internal/domains/{catalog,sales,billing,crm}`。
- 统一事务收口在 `sales.PlaceOrder` / `sales.RefundOrder`。
- 钱包切换为余额只读，一切以 `wallet_transactions` 为真相；引入幂等键。
- 订单项引入产品快照字段，保证历史可追溯。
- 建立 `outbox` 表为异步与未来拆分做铺垫。

不在本阶段范围：预约、系统调度器、短信通道；仅预留接口位。

---

### 执行路线图（PR 切片）
1. PR-0：新增领域包与事务封装（空实现），保持编译通过。
2. PR-1：Catalog（产品）与 CRM（客户/联系人）代码“搬家+接口化”，不改逻辑。
3. PR-2：Billing（钱包）重构：余额只读 + 行锁 + 幂等键；移除所有直接改余额路径；新增人工调整 API。
4. PR-3：Sales（订单）统一事务收口：下单快照 + 钱包扣减、退款反向入账；新增 outbox；补端到端测试。

---

### 统一约束与不变量
- 钱包：
  - balance = Σ(credit) - Σ(debit)；不得直接 `UPDATE wallets SET balance = ...`。
  - debit 必须绑定业务单据（`biz_ref_type='order'` & `biz_ref_id`）。
  - 交易必须带 `idempotency_key`，全局唯一。
- 订单：
  - final_amount = Σ(item.amount) - discount（单位：分）。
  - paid 只在钱包扣减成功后置位；refunded 只在返还成功后置位。
  - 事务收口：仅 `sales.PlaceOrder/RefundOrder` 能修改订单状态或触发钱包变更。

---

### 落地步骤（可复制到 Cursor）

#### Step 0：项目勘察（只读）

Plan：
- 列出目录（≤3 层）；扫描 `internal/service/*.go` 的导出方法与调用；枚举 DB 表（据 gorm-gen model/迁移）；定位风险点。

Run（仓库根执行）：
```
rg -n "(UPDATE|Set\(\"balance\"|balance\s*[+\-]=)" -g "**/*.go"
rg -n "(?i)SELECT.*FOR UPDATE|Begin\(|Commit\(|Rollback\(" -g "**/*.go"
rg -n "Idempotency|Idem|SETNX" -g "**/*.go"
```

Verify：生成《docs/architecture/REPORT_STEP0.md》；标出直接改余额、无幂等、无行锁点。

---

### PR-0：引入域包与事务封装（不改行为）

Plan：
```
internal/
  domains/
    catalog/{service.go,repo.go,model.go}
    sales/{service.go,repo.go,model.go}
    billing/{service.go,repo.go,model.go}
    crm/{service.go,repo.go,model.go}
  common/{tx.go,errors.go,outbox.go}
```
- 在各 `service.go` 定义接口（见下文接口签名）。
- `common/tx.go` 实现 `WithTx(ctx, fn)`（基于 GORM）。

Apply：提交最小可编译改动（controller 注入仍指向旧实现）。

Verify：`go build ./...` 通过。

Fallback：单 PR 回滚不影响业务逻辑。

接口签名模板：

```go
// catalog
package catalog

type Product struct { ID int64; Name string; Price int64; DurationMin int32; Status string }

type Service interface {
  Get(ctx context.Context, id int64) (Product, error)
  EnsureSellable(ctx context.Context, id int64) error
}
```

```go
// billing
package billing

type Service interface {
  Credit(ctx context.Context, customerID int64, amount int64, reason, idem string) error
  DebitForOrder(ctx context.Context, customerID, orderID int64, amount int64, idem string) error
  CreditForRefund(ctx context.Context, customerID, orderID int64, amount int64, idem string) error
}
```

```go
// sales
package sales

type OrderItemReq struct { ProductID int64; Qty int32 }

type SourceRef struct { Type string; ID int64 }

type PlaceOrderReq struct {
  CustomerID int64; Channel string; PayMethod string; Items []OrderItemReq; Discount int64; SourceRef *SourceRef; IdemKey string
}

type Order struct { ID int64; TotalAmount int64; Status, PayMethod string }

type Service interface {
  PlaceOrder(ctx context.Context, req PlaceOrderReq) (Order, error)
  RefundOrder(ctx context.Context, orderID int64, reason string) error
}
```

```go
// common/tx.go（示例实现）
package common

import (
  "context"
  "gorm.io/gorm"
)

type Tx interface { InTx(ctx context.Context) bool; WithTx(ctx context.Context, fn func(ctx context.Context) error) error }

type gormTx struct{ db *gorm.DB }
func NewTx(db *gorm.DB) Tx { return &gormTx{db: db} }

type txKey struct{}
func (t *gormTx) InTx(ctx context.Context) bool { _, ok := ctx.Value(txKey{}).(*gorm.DB); return ok }
func (t *gormTx) WithTx(ctx context.Context, fn func(ctx context.Context) error) error {
  if t.InTx(ctx) { return fn(ctx) }
  return t.db.Transaction(func(tx *gorm.DB) error { ctx2 := context.WithValue(ctx, txKey{}, tx); return fn(ctx2) })
}
```

---

### PR-1：Catalog/CRM 迁移（纯搬家）

Plan：将以下文件移动并适配接口，不改业务逻辑。
- `internal/service/product_service*.go` → `internal/domains/catalog/impl/*`
- `internal/service/customer_service*.go`、`contact_service*.go` → `internal/domains/crm/impl/*`

Apply：`impl` 满足 `catalog.Service` / `crm.Service` 接口；controller 通过构造函数注入。

Verify：现有单测/集成测全部通过。

Fallback：单 PR，可直接 `git revert`。

---

### PR-2：Billing（钱包）重构：余额只读 + 幂等

Plan：
- 新增/修订 DDL（见下节模板）：`bil_wallets`、`bil_wallet_transactions`、`sys_outbox`。
- 在 `billing.Service` 中实现：
  - `Credit`：插入一条 credit 交易，行锁钱包行，原子更新余额。
  - `DebitForOrder`：debit + 必须 `biz_ref_type='order'` 与 `biz_ref_id`。
  - `CreditForRefund`：credit + 关联原订单。
- 移除/封闭所有直接 UPDATE balance 的路径；人工调整通过 `adjust_in/out` 交易实现。
- 引入 `idempotency_key` 唯一索引；重复请求返回首单结果。

Apply：修改 `wallet_service.go` → 新接口实现；迁移 DAO 到 `dao/billing` 子包（可选）。

Verify：增加测试：充值→下单（钱包）→退款，断言余额与流水；并发扣减不越权。

Fallback：无生产数据，结构变更可直接回滚迁移与代码。

---

### PR-3：Sales（订单）收口：快照 + 钱包扣减/退款

Plan：
- DDL：给 `sal_order_items` 新增快照列（见模板）。
- 在 `sales.Service`：
  - `PlaceOrder`（事务内）：拉产品→快照→写订单/明细→若 `pay_method=wallet` 调 `billing.DebitForOrder`→写 outbox→提交。
  - `RefundOrder`（事务内）：状态置 refunded→`billing.CreditForRefund`→写 outbox。
- Controller：将 `Idempotency-Key` 从 Header 透传到 `PlaceOrderReq.IdemKey`。

Verify：端到端用例（见“自动化测试计划”）通过。

Fallback：单 PR 可回滚；数据库新增列对旧代码兼容。

---

### DDL 与迁移文件模板

在 `db/migrations` 生成三份文件：

`20250913_01_billing_tables.sql`

```
CREATE TABLE IF NOT EXISTS bil_wallets (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  customer_id BIGINT NOT NULL UNIQUE,
  balance BIGINT NOT NULL DEFAULT 0,
  status TINYINT NOT NULL DEFAULT 1,
  updated_at BIGINT NOT NULL
) ENGINE=InnoDB;

CREATE TABLE IF NOT EXISTS bil_wallet_transactions (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  wallet_id BIGINT NOT NULL,
  direction ENUM('credit','debit') NOT NULL,
  amount BIGINT NOT NULL,
  type ENUM('recharge','order_pay','order_refund','adjust_in','adjust_out') NOT NULL,
  biz_ref_type VARCHAR(32) NULL,
  biz_ref_id BIGINT NULL,
  idempotency_key VARCHAR(64) NOT NULL,
  operator_id BIGINT NULL,
  reason_code VARCHAR(32) NULL,
  note VARCHAR(255) NULL,
  created_at BIGINT NOT NULL,
  UNIQUE KEY uk_idem (idempotency_key),
  INDEX idx_wallet_time (wallet_id, created_at)
) ENGINE=InnoDB;
```

`20250913_02_sales_item_snapshots.sql`

```
ALTER TABLE sal_order_items
  ADD COLUMN IF NOT EXISTS product_name_snapshot VARCHAR(255) NULL,
  ADD COLUMN IF NOT EXISTS unit_price_snapshot BIGINT NULL,
  ADD COLUMN IF NOT EXISTS duration_min_snapshot INT NULL;
```

`20250913_03_sys_outbox.sql`

```
CREATE TABLE IF NOT EXISTS sys_outbox (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  event_type VARCHAR(64) NOT NULL,
  payload JSON NOT NULL,
  created_at BIGINT NOT NULL,
  processed_at BIGINT NULL,
  INDEX idx_type_time (event_type, created_at)
) ENGINE=InnoDB;
```

---

### 自动化测试计划

新增集成测试（`tests/integration`）：
1. 下单-现金：造客户+上架产品→下单→断言订单/明细/快照。
2. 下单-钱包：充值→下单（钱包）→断言余额减少 & 交易生成。
3. 退款-钱包：下单→退款→断言订单状态 refunded、交易 order_refund、余额回补。
4. 上架校验：下架产品下单返回 409。
5. 幂等：相同 IdemKey 重放，仅一单一扣。

为 `common.Tx` 提供 `FakeTx` 以便单元测试不启真实事务。

---

### CI/构建规范

Makefile 目标：

```
.PHONY: lint test swag build
lint: ## run linters
	golangci-lint run ./...

test: ## run tests
	go test ./... -cover -count=1

swag: ## generate swagger
	swag init -g cmd/main.go -o docs/swagger

build:
	go build ./...
```

CI：固定 Go 版本（1.22+ 或与项目一致），执行 lint → test → build → swag。

---

### 回滚策略
- 每个 PR 控制在 ≤500 行 diff；发布说明列出：改动点、影响面、回滚命令（`git revert <sha>`）。
- 数据库仅新增表/列/索引，无破坏性变更；如需回滚，保留新表但停用代码路径即可。

---

### 交付验收清单（勾选即通过）
- 目录已切换为 `internal/domains/*` 与 `internal/common/*`，编译通过。
- 所有钱包变更均通过 `billing.Service`，不存在直接改余额的 SQL。
- `sales.PlaceOrder/RefundOrder` 统一收口；订单状态与钱包变更在同事务内。
- `sal_order_items` 已写入产品快照字段。
- 端到端 5 条测试全部通过，覆盖率 ≥60%。
- `docs/architecture/BOUNDARIES.md` 与 `docs/operations/WALLET_RULES.md` 已提交。


