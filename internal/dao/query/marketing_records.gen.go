// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"crm_lite/internal/dao/model"
)

func newMarketingRecord(db *gorm.DB, opts ...gen.DOOption) marketingRecord {
	_marketingRecord := marketingRecord{}

	_marketingRecord.marketingRecordDo.UseDB(db, opts...)
	_marketingRecord.marketingRecordDo.UseModel(&model.MarketingRecord{})

	tableName := _marketingRecord.marketingRecordDo.TableName()
	_marketingRecord.ALL = field.NewAsterisk(tableName)
	_marketingRecord.ID = field.NewString(tableName, "id")
	_marketingRecord.CampaignID = field.NewString(tableName, "campaign_id")
	_marketingRecord.CustomerID = field.NewString(tableName, "customer_id")
	_marketingRecord.ContactID = field.NewString(tableName, "contact_id")
	_marketingRecord.Channel = field.NewString(tableName, "channel")
	_marketingRecord.Status = field.NewString(tableName, "status")
	_marketingRecord.ErrorMessage = field.NewString(tableName, "error_message")
	_marketingRecord.Response = field.NewString(tableName, "response")
	_marketingRecord.SentAt = field.NewTime(tableName, "sent_at")
	_marketingRecord.DeliveredAt = field.NewTime(tableName, "delivered_at")
	_marketingRecord.OpenedAt = field.NewTime(tableName, "opened_at")
	_marketingRecord.ClickedAt = field.NewTime(tableName, "clicked_at")
	_marketingRecord.RepliedAt = field.NewTime(tableName, "replied_at")
	_marketingRecord.CreatedAt = field.NewTime(tableName, "created_at")

	_marketingRecord.fillFieldMap()

	return _marketingRecord
}

type marketingRecord struct {
	marketingRecordDo

	ALL          field.Asterisk
	ID           field.String
	CampaignID   field.String
	CustomerID   field.String
	ContactID    field.String
	Channel      field.String // 触达渠道
	Status       field.String // 状态: pending, sent, delivered, failed, opened, clicked, replied, unsubscribed
	ErrorMessage field.String // 发送失败时的错误信息
	Response     field.String // 客户反馈或互动数据
	SentAt       field.Time
	DeliveredAt  field.Time
	OpenedAt     field.Time // 打开时间（邮件/推送）
	ClickedAt    field.Time // 点击时间
	RepliedAt    field.Time // 回复时间
	CreatedAt    field.Time

	fieldMap map[string]field.Expr
}

func (m marketingRecord) Table(newTableName string) *marketingRecord {
	m.marketingRecordDo.UseTable(newTableName)
	return m.updateTableName(newTableName)
}

func (m marketingRecord) As(alias string) *marketingRecord {
	m.marketingRecordDo.DO = *(m.marketingRecordDo.As(alias).(*gen.DO))
	return m.updateTableName(alias)
}

func (m *marketingRecord) updateTableName(table string) *marketingRecord {
	m.ALL = field.NewAsterisk(table)
	m.ID = field.NewString(table, "id")
	m.CampaignID = field.NewString(table, "campaign_id")
	m.CustomerID = field.NewString(table, "customer_id")
	m.ContactID = field.NewString(table, "contact_id")
	m.Channel = field.NewString(table, "channel")
	m.Status = field.NewString(table, "status")
	m.ErrorMessage = field.NewString(table, "error_message")
	m.Response = field.NewString(table, "response")
	m.SentAt = field.NewTime(table, "sent_at")
	m.DeliveredAt = field.NewTime(table, "delivered_at")
	m.OpenedAt = field.NewTime(table, "opened_at")
	m.ClickedAt = field.NewTime(table, "clicked_at")
	m.RepliedAt = field.NewTime(table, "replied_at")
	m.CreatedAt = field.NewTime(table, "created_at")

	m.fillFieldMap()

	return m
}

func (m *marketingRecord) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := m.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (m *marketingRecord) fillFieldMap() {
	m.fieldMap = make(map[string]field.Expr, 14)
	m.fieldMap["id"] = m.ID
	m.fieldMap["campaign_id"] = m.CampaignID
	m.fieldMap["customer_id"] = m.CustomerID
	m.fieldMap["contact_id"] = m.ContactID
	m.fieldMap["channel"] = m.Channel
	m.fieldMap["status"] = m.Status
	m.fieldMap["error_message"] = m.ErrorMessage
	m.fieldMap["response"] = m.Response
	m.fieldMap["sent_at"] = m.SentAt
	m.fieldMap["delivered_at"] = m.DeliveredAt
	m.fieldMap["opened_at"] = m.OpenedAt
	m.fieldMap["clicked_at"] = m.ClickedAt
	m.fieldMap["replied_at"] = m.RepliedAt
	m.fieldMap["created_at"] = m.CreatedAt
}

func (m marketingRecord) clone(db *gorm.DB) marketingRecord {
	m.marketingRecordDo.ReplaceConnPool(db.Statement.ConnPool)
	return m
}

func (m marketingRecord) replaceDB(db *gorm.DB) marketingRecord {
	m.marketingRecordDo.ReplaceDB(db)
	return m
}

type marketingRecordDo struct{ gen.DO }

type IMarketingRecordDo interface {
	gen.SubQuery
	Debug() IMarketingRecordDo
	WithContext(ctx context.Context) IMarketingRecordDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IMarketingRecordDo
	WriteDB() IMarketingRecordDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IMarketingRecordDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IMarketingRecordDo
	Not(conds ...gen.Condition) IMarketingRecordDo
	Or(conds ...gen.Condition) IMarketingRecordDo
	Select(conds ...field.Expr) IMarketingRecordDo
	Where(conds ...gen.Condition) IMarketingRecordDo
	Order(conds ...field.Expr) IMarketingRecordDo
	Distinct(cols ...field.Expr) IMarketingRecordDo
	Omit(cols ...field.Expr) IMarketingRecordDo
	Join(table schema.Tabler, on ...field.Expr) IMarketingRecordDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IMarketingRecordDo
	RightJoin(table schema.Tabler, on ...field.Expr) IMarketingRecordDo
	Group(cols ...field.Expr) IMarketingRecordDo
	Having(conds ...gen.Condition) IMarketingRecordDo
	Limit(limit int) IMarketingRecordDo
	Offset(offset int) IMarketingRecordDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IMarketingRecordDo
	Unscoped() IMarketingRecordDo
	Create(values ...*model.MarketingRecord) error
	CreateInBatches(values []*model.MarketingRecord, batchSize int) error
	Save(values ...*model.MarketingRecord) error
	First() (*model.MarketingRecord, error)
	Take() (*model.MarketingRecord, error)
	Last() (*model.MarketingRecord, error)
	Find() ([]*model.MarketingRecord, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.MarketingRecord, err error)
	FindInBatches(result *[]*model.MarketingRecord, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.MarketingRecord) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IMarketingRecordDo
	Assign(attrs ...field.AssignExpr) IMarketingRecordDo
	Joins(fields ...field.RelationField) IMarketingRecordDo
	Preload(fields ...field.RelationField) IMarketingRecordDo
	FirstOrInit() (*model.MarketingRecord, error)
	FirstOrCreate() (*model.MarketingRecord, error)
	FindByPage(offset int, limit int) (result []*model.MarketingRecord, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IMarketingRecordDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (m marketingRecordDo) Debug() IMarketingRecordDo {
	return m.withDO(m.DO.Debug())
}

func (m marketingRecordDo) WithContext(ctx context.Context) IMarketingRecordDo {
	return m.withDO(m.DO.WithContext(ctx))
}

func (m marketingRecordDo) ReadDB() IMarketingRecordDo {
	return m.Clauses(dbresolver.Read)
}

func (m marketingRecordDo) WriteDB() IMarketingRecordDo {
	return m.Clauses(dbresolver.Write)
}

func (m marketingRecordDo) Session(config *gorm.Session) IMarketingRecordDo {
	return m.withDO(m.DO.Session(config))
}

func (m marketingRecordDo) Clauses(conds ...clause.Expression) IMarketingRecordDo {
	return m.withDO(m.DO.Clauses(conds...))
}

func (m marketingRecordDo) Returning(value interface{}, columns ...string) IMarketingRecordDo {
	return m.withDO(m.DO.Returning(value, columns...))
}

func (m marketingRecordDo) Not(conds ...gen.Condition) IMarketingRecordDo {
	return m.withDO(m.DO.Not(conds...))
}

func (m marketingRecordDo) Or(conds ...gen.Condition) IMarketingRecordDo {
	return m.withDO(m.DO.Or(conds...))
}

func (m marketingRecordDo) Select(conds ...field.Expr) IMarketingRecordDo {
	return m.withDO(m.DO.Select(conds...))
}

func (m marketingRecordDo) Where(conds ...gen.Condition) IMarketingRecordDo {
	return m.withDO(m.DO.Where(conds...))
}

func (m marketingRecordDo) Order(conds ...field.Expr) IMarketingRecordDo {
	return m.withDO(m.DO.Order(conds...))
}

func (m marketingRecordDo) Distinct(cols ...field.Expr) IMarketingRecordDo {
	return m.withDO(m.DO.Distinct(cols...))
}

func (m marketingRecordDo) Omit(cols ...field.Expr) IMarketingRecordDo {
	return m.withDO(m.DO.Omit(cols...))
}

func (m marketingRecordDo) Join(table schema.Tabler, on ...field.Expr) IMarketingRecordDo {
	return m.withDO(m.DO.Join(table, on...))
}

func (m marketingRecordDo) LeftJoin(table schema.Tabler, on ...field.Expr) IMarketingRecordDo {
	return m.withDO(m.DO.LeftJoin(table, on...))
}

func (m marketingRecordDo) RightJoin(table schema.Tabler, on ...field.Expr) IMarketingRecordDo {
	return m.withDO(m.DO.RightJoin(table, on...))
}

func (m marketingRecordDo) Group(cols ...field.Expr) IMarketingRecordDo {
	return m.withDO(m.DO.Group(cols...))
}

func (m marketingRecordDo) Having(conds ...gen.Condition) IMarketingRecordDo {
	return m.withDO(m.DO.Having(conds...))
}

func (m marketingRecordDo) Limit(limit int) IMarketingRecordDo {
	return m.withDO(m.DO.Limit(limit))
}

func (m marketingRecordDo) Offset(offset int) IMarketingRecordDo {
	return m.withDO(m.DO.Offset(offset))
}

func (m marketingRecordDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IMarketingRecordDo {
	return m.withDO(m.DO.Scopes(funcs...))
}

func (m marketingRecordDo) Unscoped() IMarketingRecordDo {
	return m.withDO(m.DO.Unscoped())
}

func (m marketingRecordDo) Create(values ...*model.MarketingRecord) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Create(values)
}

func (m marketingRecordDo) CreateInBatches(values []*model.MarketingRecord, batchSize int) error {
	return m.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (m marketingRecordDo) Save(values ...*model.MarketingRecord) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Save(values)
}

func (m marketingRecordDo) First() (*model.MarketingRecord, error) {
	if result, err := m.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.MarketingRecord), nil
	}
}

func (m marketingRecordDo) Take() (*model.MarketingRecord, error) {
	if result, err := m.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.MarketingRecord), nil
	}
}

func (m marketingRecordDo) Last() (*model.MarketingRecord, error) {
	if result, err := m.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.MarketingRecord), nil
	}
}

func (m marketingRecordDo) Find() ([]*model.MarketingRecord, error) {
	result, err := m.DO.Find()
	return result.([]*model.MarketingRecord), err
}

func (m marketingRecordDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.MarketingRecord, err error) {
	buf := make([]*model.MarketingRecord, 0, batchSize)
	err = m.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (m marketingRecordDo) FindInBatches(result *[]*model.MarketingRecord, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return m.DO.FindInBatches(result, batchSize, fc)
}

func (m marketingRecordDo) Attrs(attrs ...field.AssignExpr) IMarketingRecordDo {
	return m.withDO(m.DO.Attrs(attrs...))
}

func (m marketingRecordDo) Assign(attrs ...field.AssignExpr) IMarketingRecordDo {
	return m.withDO(m.DO.Assign(attrs...))
}

func (m marketingRecordDo) Joins(fields ...field.RelationField) IMarketingRecordDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Joins(_f))
	}
	return &m
}

func (m marketingRecordDo) Preload(fields ...field.RelationField) IMarketingRecordDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Preload(_f))
	}
	return &m
}

func (m marketingRecordDo) FirstOrInit() (*model.MarketingRecord, error) {
	if result, err := m.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.MarketingRecord), nil
	}
}

func (m marketingRecordDo) FirstOrCreate() (*model.MarketingRecord, error) {
	if result, err := m.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.MarketingRecord), nil
	}
}

func (m marketingRecordDo) FindByPage(offset int, limit int) (result []*model.MarketingRecord, count int64, err error) {
	result, err = m.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = m.Offset(-1).Limit(-1).Count()
	return
}

func (m marketingRecordDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = m.Count()
	if err != nil {
		return
	}

	err = m.Offset(offset).Limit(limit).Scan(result)
	return
}

func (m marketingRecordDo) Scan(result interface{}) (err error) {
	return m.DO.Scan(result)
}

func (m marketingRecordDo) Delete(models ...*model.MarketingRecord) (result gen.ResultInfo, err error) {
	return m.DO.Delete(models)
}

func (m *marketingRecordDo) withDO(do gen.Dao) *marketingRecordDo {
	m.DO = *do.(*gen.DO)
	return m
}
